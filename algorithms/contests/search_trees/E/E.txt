https://codeforces.com/group/PVbQ8eK2T4/contest/357142/problem/E

E. Множества
ограничение по времени на тест 0.75 секунд
ограничение по памяти на тест 256 мегабайт
ввод стандартный ввод
вывод стандартный вывод

На вступительном контесте в пилотную группу по программированию Вашему другу предложили реализовать структуру данных для хранения множеств чисел. Так как он специализируется на истории литературы, данную структуру придётся реализовать Вам.

Структура должна хранить m+1 множеств чисел от 0 до n, пронумерованных от 0 до m включительно, при этом одно число может принадлежать сразу нескольким множествам. Изначально все множества пустые.

Вы должны реализовать следующие операции на этой структуре:

    ADD e s Добавить в множество №s (0<=s<=m) число e (0<=e<=n).
    DELETE e s Удалить из множества №s (0<=s<=m) число e (0<=e<=n). Гарантируется, что до этого число e было помещено в множество
    CLEAR s Очистить множество №s (0<=s<=m).
    LISTSET s Показать содержимое множества №s (0<=s<=m) в возрастающем порядке, либо −1, если множество пусто.
    LISTSETSOF e Вывести номера множеств, в которых лежит число e (0<=e<=n) в возрастающем порядке, либо −1, если этого числа нет ни в одном множестве. 

Входные данные
Сначала вводятся числа N
(1<=N<=9223372036854775807), M (1<=M<=100000) и K (0<=K<=100000)  — максимальное число, номер максимального множества и количество запросов к структуре данных. Далее следуют K строк указанного формата запросов.

Выходные данные
На каждый запрос LISTSET Ваша программа должна вывести числа  — содержимое запрошенного множества или −1, если множество пусто.
На каждый запрос LISTSETSOF Ваша программа должна вывести числа  — номера множеств, содержащих запрошенное число, или −1, если таких множеств не существует.
На прочие запросы не должно быть никакого вывода.
Гарантируется, что правильный вывод программы не превышает одного мегабайта.

Пример
Входные данные
10 10
9
ADD 1 1
ADD 1 2
ADD 2 1
LISTSET 1
LISTSETSOF 1
DELETE 1 1
LISTSET 1
CLEAR 1
LISTSET 1
Выходные данные
1 2 
1 2 
2 
-1

Примечание
Эту задачу можно (и нужно!) решать, используя std::set и std::map.
