# Fibers, Oh My!

## Пререквизиты

- [tasks/thread-pool](/tasks/tasks/thread-pool)
- [fibers/coro](/tasks/fibers/coro)

---

## От корутин к файберам

В этой задаче вы должны написать многопоточные файберы.

Планировщик для файберов вами [уже реализован](tasks/tasks/thread-pool), это пул потоков.

Механизм остановки / возобновления исполнения – [тоже](tasks/fibers/coro), это stackful корутина.

Остается лишь скомбинировать их!

## Файберы

Так будет выглядеть результат:

```cpp
void FibersExample() {
  // В этой задаче мы начнем писать свой фреймворк для concurrency
  // Он будет называться `exe` (от execution)
  using namespace exe;

  // Пул потоков будет служить планировщиком для файберов
  tp::ThreadPool scheduler{/*threads=*/4};
  scheduler.Start();

  for (size_t i = 0; i < 256; ++i) {
    // Запускаем файбер в пуле-планировщике
    fibers::Go(scheduler, [] {
      for (size_t j = 0; j < 3; ++j) {
        // Уступаем поток планировщика другому файберу
        fibers::Yield();
      }  
    });
  }
  
  // Файберы исполняются _параллельно_ на разных потоках пула-планировщика

  // Дожидаемся завершения файберов
  scheduler.WaitIdle();
  // Выключаем планировщик
  scheduler.Stop();
}  
```

В этой задаче мы реализуем лишь базовые "системные вызовы" к планировщику ([fibers/sched](exe/fibers/sched)):

- `Go(Scheduler&, Routine)` – запланировать процедуру на исполнение в файбере в заданный планировщик
- `Go(Routine)` – запланировать процедуру на исполнение в файбере в текущий планировщик
- `Yield` – перепланировать текущий файбер, уступить поток планировщика другим файберам

Позже мы научим файберы [синхронизации](/tasks/fibers/mutex).

## Дизайн

Реализацию файберов мы сводим к комбинированию двух ортогональных компонентов:

- Пул потоков
- Stackful корутина

Пул потоков параллельно исполняет абстрактные задачи (функциональные объекты), но ничего не знает про их природу.

Корутины – suspendable процедуры, они ничего не знают про пулы потоков и кооперативную многозадачность.

Ваша задача: __не меняя<sup>†</sup> эти компоненты__, сохраняя их ортогональность, выразить через них `Go` и `Yield` файберов.

† Цель, разумеется, не в полном отсутствии изменений, а в том, чтобы детали реализации файберов не проникали в пул / корутину, а сами пул и корутина по-прежнему хорошо подходили для других своих приложений.

### Развитие 

В будущем декомпозиция, на которой основан наш дизайн, позволит **независимо** развивать (и усложнять) и планировщик, и файберы:
- В планировщике будет оптимизирован алгоритм планирования задач
- В файберах появятся примитивы синхронизации

### Обязанности 

Чтобы лучше понять предложенный дизайн, подумайте над распределением обязанностей между сущностями
- _задача_ (`Task`),
- _корутина_ (`Coroutine`) и
- _файбер_ (`Fiber`).

## References

- [Loom](https://wiki.openjdk.org/display/loom/Main)
    - [Project Loom: Fibers and Continuations for the Java Virtual Machine](https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html)
    - [Ron Pressler and Alan Bateman – Project Loom](https://www.youtube.com/watch?v=J31o0ZMQEnI)
    - [State of Loom](https://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part1.html)
- [Fibers, Oh My!](https://graphitemaster.github.io/fibers/)

## Структура `exe`

- [`coro`](exe/coro) – корутины
- [`tp`](exe/tp) – пул потоков (планировщик задач)
- [`fibers`](exe/fibers) – файберы, зависят от `tp` и `coro`
  - `sched` – системные вызовы к планировщику
  - `sync` – примитивы синхронизации
- [`threads`](exe/threads) – синхронизация для потоков (мьютекс, кондвар, спинлок и т.п.)
- [`support`](exe/support) – полезные мелочи

Пользователь библиотеки работает только с
- `tp` и
- `fibers/{sched, sync}`

## Задание

1) Перенесите в [exe/tp](exe/tp/thread_pool.hpp) реализацию пула потоков из задачи [tasks/thread-pool](/tasks/tasks/thread-pool)
2) Перенесите в [exe/coro](exe/coro/) реализацию корутины из задачи [fibers/coro](/tasks/fibers/coro) 
3) Через `ThreadPool` и `Coroutine` выразите [файберы](exe/fibers/)

Код эволюционирует, так что в пунктах 1) и 2) потребуются косметические изменения: нужно будет двигать файлы, корректировать инклюды, оборачивать код в дополнительные пространства имен и т.п.

## Замечания по реализации

### Время жизни

Аллоцируйте файберы на куче.

Не используйте умные указатели для контроля времени жизни файбера. Такой подход не будет работать
с очередями ожидания в примитивах синхронизации, которые появятся в будущих задачах.

[Is it legal (and moral) for a member function to say `delete this`?](https://isocpp.org/wiki/faq/freestore-mgmt#delete-this)

### Планировщик

Рекомендуем вместо использования `ThreadPool::Current`  хранить указатель на планировщик прямо в полях файбера.

В будущем мы обобщим пул потоков до абстрактного _экзекутора_ (_executor_), и тогда аналогичный метод написать / использовать уже не получится.

### Coroutine Core

В долгосрочной перспективе вы увидите, что строить файберы с помощью наивной корутины неэффективно.

Подумайте над тем, чтобы вынести общее _ядро_ корутины, которое потом можно использовать и в `SimpleCoroutine`, и в `Fiber`:

Тестируется только `SimpleCoroutine` из `coro/simple.hpp`.

### Std-like

[Продолжайте использовать](exe/threads/stdlike) собственные реализации `Mutex` и `CondVar`.

### `Submit`

Будем считать, что все пользователи, запускающие в пуле потоков лямбды, пользуются не методом 
 `Submit`, а свободной функцией `tp::Submit`:

```cpp
void SubmitExample() {
  using namespace exe;
  
  tp::ThreadPool pool{4};
  pool.Start();
  
  tp::Submit(pool, [] {
    std::println("Hello");
  });
  
  pool.WaitIdle();
  pool.Stop();
}
```

В тестах задачи лямбды в пул потоков планируются только с помощью `tp::Submit`.

### Misc

Класс `Fiber` не должен быть виден пользователю через публичное API.
