# Executors

## Пререквизиты

- [tasks/thread-pool](/tasks/tasks/thread-pool)
- [fibers/yield](/tasks/fibers/yield)

## Декомпозиция

_Futures_, _stackful fibers_, _stackless coroutines_ – это _выразительные средства_, с помощью которых разработчик описывает конкурентные активности в своем приложении.

Для разработчика эти средства существенно отличаются друг от друга. А для _среды исполнения_ (пула потоков) они, наоборот, выглядят одинаково – как цепочки быстрых неблокирующихся задач.

Concurrency декомпозирована:
- _Выразительные средства_ _описывают_ цепочки задач
- _Среда исполнения_ _исполняет_ эти цепочки

## Абстракция

В этой задаче мы абстрагируем среду исполнения: фьючи, файберы и корутины будут запускать свои задачи не в конкретном пуле потоков, а в абстрактном _экзекуторе_.

## Executor

_Executors are to function execution as allocators are to memory allocation_.

_Экзекутор_ (_executor_) – это сервис, исполняющий задачи. 

Экзекутор реализует интерфейс [`IExecutor`](exe/executors/executor.hpp) с единственным методом `Submit` – запланировать задачу на исполнение.

Единственная гарантия, которую экзекутор дает своему пользователю: _запланированная в него задача будет исполнена_.

В каком потоке и когда именно – зависит от конкретной реализации интерфейса `IExecutor`. Механика исполнения задач скрыта от пользователя за виртуальным вызовом.

## Дизайн

- _Выразительные средства_ (фьючи, файберы, корутины) описывают _что_ исполнять
- _Экзекуторы_ (`ThreadPool`, `ManualExecutor`, `Strand`) – _как_ исполнять
- `IExecutor` – граница, разделяющая выразительные средства и среду исполнения задач, позволяющая их комбинировать

## Реализации

### Пул потоков

[`ThreadPool`](exe/executors/tp/compute/thread_pool.hpp) – статический набор потоков-воркеров, разбирающих общую очередь задач.

```cpp
void ThreadPoolExample() {
  using namespace exe;
  
  // ThreadPool реализует интерфейс IExecutor
  executors::ThreadPool pool{/*threads=*/4};
  pool.Start();
  
  executors::Submit(pool, [] {
    fmt::println("Running on thread pool");
  });
  
  // Дожидаемся завершения всех задач
  pool.WaitIdle();
  // Останавливаем пул
  pool.Stop();
}
```

#### Применение

Мы [уже использовали](/tasks/fibers/yield) пул потоков как планировщик для файберов. 

При этом файберам совсем не обязательно знать, что планировщик – это именно пул потоков, файберам достаточно абстракции `IExecutor` и ее базовой гарантии.

Так что уточним определение: файбер – это корутина + **executor**, который ее выполняет.

### Manual

[`ManualExecutor`](exe/executors/manual.hpp) – это всего лишь очередь задач.

Вызов `Submit` добавляет задачу в конец этой очереди.

Задачи, запланированные в `ManualExecutor`, запускаются **вручную** с помощью методов `RunNext`, `RunAtMost` и `Drain`. 

Собственных потоков у `ManualExecutor` нет.

С `ManualExecutor` должен работать только один поток.

#### Пример

```cpp
void ManualExample() {
  using namespace exe;
  
  // ManualExecutor – очередь задач
  executors::ManualExecutor manual;
  
  // Добавляем задачу в очередь
  executors::Submit(manual, [] {
    fmt::println("1st");
  });
  
  // И еще одну
  executors::Submit(manual, [] {
    fmt::println("2nd");
  });

  // <-- Теперь обе задачи находятся в очереди ManualExecutor-а,
  // пока ни одна из них не была запущена

  // Запустим первую задачу
  manual.RunNext();

  // Запланируем третью задачу
  executors::Submit(manual, [] {
    fmt::println("3rd");
  });

  // "Опустошаем" очередь задач, т.е.
  // исполняем задачи до тех пор, пока очередь не опустеет
  manual.Drain();
  // <-- К этому моменту выполнились все три задачи
}
```

#### Применение

С помощью `ManualExecutor` файберы можно исполнять по шагам, что позволяет писать для них **детерминированные юнит-тесты**!

```cpp
void ManualFibers() {
  using namespace exe;

  executors::ManualExecutor scheduler;
  
  fibers::Go(scheduler, [] {
    fibers::Yield();
  });

  fibers::Go(scheduler, [] {
    fibers::Yield();
  });
  
  // <-- Пока ни один файбер не начал исполняться
  
  // Первый шаг первым файбером
  scheduler.RunNext();
  // <-- Первый файбер зашел в `Yield`
  
  // Первый шаг вторым файбером
  scheduler.RunNext();
  // <-- Второй файбер зашел в `Yield`
  
  scheduler.Drain();
}
```

Таким образом, файберы 
- исполняются в `ThreadPool`, 
- тестируются в `ManualExecutor`

### Strand

#### Проблема

Задачам в пуле потоков может понадобиться взаимное исключение.

Использовать непосредственно мьютексы нежелательно: если задача в пуле захватила мьютекс на продолжительное время, то другие задачи, которым нужен этот же мьютекс, заблокируют потоки пула и помешают исполняться другим задачам, которым этот мьютекс вообще не нужен.

#### Асинхронный мьютекс

Экзекуторы предоставляют альтернативу: _асинхронный мьютекс_ или `Strand`.

[`Strand`](exe/executors/strand.hpp) – экзекутор, запускающий задачи (можно назвать их критическими секциями) строго **последовательно**, в порядке их планирования (вообще говоря, этот порядок частичный – _happens-before_).

Планировать задачи в `Strand` можно из разных потоков без внешней синхронизации.

#### Декоратор

`Strand` не имеет собственных потоков, это декоратор, который оборачивает произвольный экзекутор и делегирует тому исполнение своих задач.

`Strand` не делает никаких предположений об устройстве декорируемого экзекутора. Единственная гарантия, на которую `Strand` полагается, – каждая запланированная
в декорируемый экзекутор задача однажды будет выполнена.

Один и тот же пул потоков могут использовать для исполнения произвольное число `Strand`-ов.

#### Пример

```cpp
void StrandExample() {
  using namespace exe::executors;
  
  // Потоки, исполняющие задачи
  ThreadPool workers{4};
  // Декоратор над пулом потоков `workers`
  // Сам `strand` не знает, что он декорирует именно пул потоков
  Strand strand{workers};
  
  ThreadPool clients{5};
  
  size_t cs = 0;
  
  // Запускаем в пуле `clients` задачи, которые будут
  // параллельно планировать критические секции в `strand`
  
  for (size_t i = 0; i < 1024; ++i) {
    Submit(clients, [&] {
      // Следующий `Submit` вызывается из разных потоков пула `clients`
      Submit(strand, [&] {
        // Асинхронная критическая секция
        ++cs;
      });
    });
  }
  
  // Ждем завершения клиентов
  clients.WaitIdle();
  // Ждем завершения секций
  workers.WaitIdle();
  
  fmt::println("# critical sections: {}", cs);
  // <-- Напечатано 1024
  
  clients.Stop();
  workers.Stop();
}
```

#### `Strand` и мьютекс

##### Мьютекс

С точки зрения протокола когерентности кэшей, синхронный мьютекс – неэффективный примитив синхронизации:

Чем больше число ядер / потоков, исполняющих критические секции, тем выше накладные расходы на когерентность, так как разделяемые данные, к которым обращаются критические секции, приходится постоянно двигать между ядрами.

##### Strand

Гораздо разумнее не данные "двигать" между ядрами к критическим секциям, а наоборот – критические секции собрать на одном ядре, и на нем обрабатывать данные. Тогда секции будут работать над "прогретым" кэшом.

Это и будет делать `Strand`. 

Чем больше будет нагрузка на `Strand`, тем **меньше** будет в исполнении синхронизации, и тем эффективнее будут исполняться критические секции пользователей (в отличие от обычного мьютекса, в котором все наоборот)!

## Задание

1) Перенесите в [executors/tp/compute](exe/executors/tp/compute) реализацию пула потоков
2) Реализуйте [`ManualExecutor`](exe/executors/manual.hpp)
3) Реализуйте [`Strand`](exe/executors/strand.hpp) используя взаимное исключение
4) Реализуйте `Strand` через лок-фри очередь

## Реализация

### `Strand`

#### Серии

`Strand` должен исполнять задачи _сериями_ или _пакетами_ (_batching_).

1) Серийность позволит избавиться от синхронизации между критическими секциями при исполнении серии.
2) Критические секции внутри серии будут работать над прогретым кэшом.

Серии должны адаптироваться под нагрузку:

- Чем больше нагрузка на `Strand`, тем больше должны быть серии, и тем меньше должно быть синхронизации в исполнении.
  - Серии могут получаться сколь угодно большими, но все же должны оставаться конечными.
- При этом `Strand` не должен искусственно задерживать исполнение задач.

#### Синхронизация

##### Спинлок

Простая реализация `Strand` будет использовать взаимное исключение для доступа к очереди задач.

Реализуйте и используйте [Test-and-TAS спинлок](exe/threads/spinlock.hpp). В критической секции спинлока в `Strand` должна выполняться константная работа.

##### Lock-free

Избавьтесь от взаимного исключения: храните задачи `Strand`-а в лок-фри очереди. Вам пригодится умение строить очередь из двух стеков.

Продумайте управление памятью в вашей реализации.

Если вы все сделали правильно, то реализация лок-фри очереди для `Strand` получится очень простой.

#### `fibers::Mutex`

В этой задаче вы реализуете **асинхронный** серийный лок-фри мьютекс.

А теперь вспомним, что файберы с помощью переключения контекста могут превращать асинхронные интерфейсы в синхронные.

Воспользуйтесь этим наблюдением и реализуйте для файберов **синхронный** серийный лок-фри мьютекс в задаче [`fibers/mutex`](/tasks/fibers/mutex).


### Интрузивность

Бонусный уровень<sup>†</sup>!

Реализуйте [интрузивные задачи](intrusive.md) и избавьтесь от динамических аллокаций памяти при планировании файберов.

† Бонусный для данной задачи, для хорошей реализации файберов – обязательный.