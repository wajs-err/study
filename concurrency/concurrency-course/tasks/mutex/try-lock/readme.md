# TryLock для TicketLock

Реализуйте метод `TryLock` для [`TicketLock`](ticket_lock.hpp).

Семантика `TryLock`:

* Если лок свободен, то захватить его **без ожидания** и вернуть `true`
* Если лок захвачен другим потоком, и текущему потоку нужно ждать освобождения блокировки, то **без ожидания** вернуть `false`

Если вызов `TryLock()` вернул `true`, то поток захватил спинлок и находится в критической секции.

Каждый поток, прошедший через `Lock` или успешный `TryLock`, должен получать от спинлока уникальный порядковый номер.

Вызов метода `TryLock` должен завершаться за конечное число шагов, которое не зависит от числа потоков, разрядности машинного слова и т.п. В частности, в реализации `TryLock` нельзя вызывать метод `Lock`: число итераций в цикле ожидания в `Lock` зависит от числа потоков в очереди перед нами.

Неудачные попытки `TryLock` не должны приводить к вечным блокировкам вызовов `Lock`.

Изучите также гарантии [`try_lock` у `std::mutex`](https://en.cppreference.com/w/cpp/thread/mutex/try_lock).

---

В решении вы можете использовать любые атомарные RMW-операции, которые есть у [std::atomic](https://en.cppreference.com/w/cpp/atomic/atomic).

Реализацию методов `Lock` и `Unlock` менять нельзя.
