# Обедающие философы

За круглым столом сидят $`n`$ философов. Перед каждым из них стоит тарелка с пастой. Между каждой парой соседних философов лежит вилка.

Каждый философ за столом следует алгоритму:

1) Берет две лежащие рядом вилки
2) Ест пасту
3) Кладет вилки обратно на стол
4) [Размышляет над чем-то](https://en.wikipedia.org/wiki/A_History_of_Western_Philosophy)
5) Затем повторяет все сначала

Зачем есть пасту двумя вилками – не ясно, но так устроены философы.

Разумеется, два сидящих рядом философа не могут есть одновременно, поскольку они делят между собой по крайней мере одну вилку.

Вам нужно научить философов брать и отпускать вилки таким образом, чтобы они не могли навечно заблокировать друг друга и умереть от голода.

## Вилки и мьютексы

В нашей задаче философы – это потоки, вилки – мьютексы, а сама задача – про то, чтобы придумать стратегию _deadlock prevention_.

## Задание (начало)

Реализуйте методы `AcquireForks` и `ReleaseForks` в файле [`philosopher.cpp`](philosopher.cpp) таким образом, чтобы дэдлок гарантированно не мог возникнуть.

Каждый философ знает свое место за столом (поле `seat_`) и вилки слева (`left_fork_`) и справа (`right_fork_`) от себя. Ничем другим он пользоваться не должен.

Использовать функцию [`std::lock`](https://en.cppreference.com/w/cpp/thread/lock) запрещается (не из вредности, а потому что у этой функции [дурной запах](https://en.wikipedia.org/wiki/Code_smell)).

## Deadlock prevention / avoidance

Если в своем решении вы используете метод мьютекса `try_lock`, то скорее всего вы реализовали _deadlock avoidance_, а не _deadlock prevention_.

В решении с _deadlock prevention_ нужно использовать только методы `lock` и `unlock`.

## Wait-For Graph

Построим двудольный направленный граф, который назовем _графом ожидания_ (_wait-for graph_). 

Вершинами в нем будут потоки и мьютексы. 

Дуги возникают и исчезают по следующим правилам:
- Когда поток `T` вызывает метод `Lock` на мьютексе `M`, то в графе появляется направленная дуга `T` → `M` (поток `T` _ждет_ мьютекса `M`).
- Когда вызов `Lock` завершается и поток `Т` захватывает мьютекс `M`, то мы стираем эту дугу и проводим противоположную, `M` → `T` (мьютекс `M` _во владении_ потока `T`).
- Когда поток `T` отпускает мьютекс (вызывает метод `Unlock`), то мы стираем дугу из `M` в `T`.

## Задание (продолжение)

1) Дайте определение дэдлоку в терминах графа ожидания
2) Докажите с помощью графа ожидания, что ваша стратегия взятия вилок гарантирует невозможность дэдлока
3) Придумайте общий рецепт безопасного захвата нескольких мьютексов (без привязки к философам, вилкам и круглому столу) и убедитесь, что конкретное правило взятия вилок философами – проекция этого общего решения

## Unlock

Даже два мьютекса захватить непросто. А как их правильно отпускать? [Отвечает](https://lkml.org/lkml/2008/10/8/150) Линус Торвальдс ([предупреждение: в ответе содержится ненормативная лексика!](https://www.newyorker.com/science/elements/after-years-of-abusive-e-mails-the-creator-of-linux-steps-aside)).

## Thread Sanitizer

Напишите дэдлок и запустите стресс-тесты в сборке с [ThreadSanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html) с помощью команды:

```shell
clippy target stress_tests FaultyThreadsTSan
```

Что означает предупреждение _lock-order-inversion_?
