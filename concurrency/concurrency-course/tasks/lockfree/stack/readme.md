# Treiber Stack

Реализуйте [лок-фри MPMC стек Трeйбера](https://en.wikipedia.org/wiki/Treiber_stack).

## Подсчет ссылок

Для управления памятью будем использовать подсчет ссылок:

Поток, читающий `top_` в `TryPop`, будет получать сильную ссылку на узел, которая будет продлять время его жизни через инкремент счетчика ссылок.

Если хранить счетчик ссылок на узел непосредственно самом узле, то мы столкнемся с проблемой:

В `TryPop` нужно
1) прочесть `top_` и 
2) увеличить счетчик узла, на который указывает `top_`.

Но между шагом 1) и 2) другой поток может извлечь и удалить узел, счетчик которого мы хотели увеличить.

Так что чтение `top_` и инкремент счетчика ссылок нужно выполнять **атомарно**.

## Дифференцированый подсчет ссылок

[Differential Reference Counting](https://www.1024cores.net/home/lock-free-algorithms/object-life-time-management/differential-reference-counting)

Разделим счетчик ссылок для каждого узла на две компоненты:

- _inner count_ – хранится **в самом узле**, аккумулирует все **декременты** + **eventually** все **инкременты**,
- _outer count_ – аккумулирует все **инкременты**, хранится прямо  **на указателе** на узел.

### `AtomicStampedPtr`

Для реализации вам потребуется класс [`AtomicStampedPtr<T>`](atomic_stamped_ptr.hpp).

`AtomicStampedPtr<T>` хранит указатель + 16-битный счетчик в виде одного машинного слова и умеет выполнять над этой парой стандартные атомарные операции:

```cpp
AtomicStampedPtr<T> asp({nullptr, 0});

// Записываем в `asp` пару (указатель, счетчик)
asp.Store({raw_ptr, 7});

// Читаем указатель в виде `StampedPtr` c полями `raw_ptr` и `stamp`
StampedPtr<T> stamped_ptr = asp.Load();

// Метод `IncrementStamp` возвращает новый `StampedPtr`, 
// в котором счетчик увеличен на единицу
bool succeeded = asp.CompareExchangeWeak(stamped_ptr, stamped_ptr.IncrementStamp());
```

Счетчик в `[Atomic]StampedPtr` самостоятельного смысла не имеет. В этой задаче мы будем использовать его для хранения _outer count_ головы стека.

### `AtomicSharedPtr`

В этой задаче инкременты могут переполнить выделенные для внешнего счетчика биты указателя. Эту проблему мы решим в задаче [lockfree/shared_ptr](/tasks/lockfree/shared_ptr).