# Work-Stealing Queue

Реализуйте [`WorkStealingQueue`](work_stealing_queue.hpp), которая послужит локальной очередью задач для потоков-воркеров [шардированного планировщика](/tasks/tasks/scheduler).

## Хранение

Очередь реализована через циклический буфер. Емкость очереди / размер буфера задается через параметр шаблона.

Очередь хранит указатели на данные, а не сами данные.

## Операции

- `bool TryPush(T* item)` – если в очереди есть свободные слоты, то добавить `item` в хвост очереди и вернуть `true`. Если буфер очереди переполнился, то вернуть `false`.
- `T* TryPop()` – извлечь элемент (указатель) из головы очереди. Если очередь пуста, то вернуть `nullptr`.
- `size_t Grab(std::span<T*> out_buffer)` – забрать пачку элементов из головы очереди, переложив их в `out_buffer`, вернуть число извлеченных элементов.

Метод `Grab` представлен в API потому что он реализуется эффективнее, чем серия `TryPop`.

## Паттерн доступа

Паттерн доступа – вариация _Single Producer_ / _Multiple Consumers_:
- Методы `TryPush` и `TryPop` вызывает только один выделенный поток.
- Метод `Grab` могут вызывать конкурентно (с другими `Grab` и `TryPop` / `TryPush`) нескольких потоков.

## Требования

- Lock-freedom
- Оптимальные `memory_order`-ы.

## Планировщик

В шардированном планировщике
- В очереди хранятся указатели на _задачи_.
- Методы `TryPush` и `TryPop` вызывает _поток-воркер_, владеющий очередью.
- Метод `Grab` используется при _балансировке нагрузки_:
  * другими воркерами для _воровства задач_ (_work-stealing_),
  * самим воркером для выгрузки пачки задач в общую очередь при переполнении локальной.
