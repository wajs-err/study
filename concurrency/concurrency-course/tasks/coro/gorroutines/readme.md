# Gor-routines

## Пререквизиты

- [tasks/executors](/tasks/tasks/executors)
- [fibers/mutex](/tasks/fibers/mutex) – рекомендуется
- [tasks/scheduler](/tasks/tasks/scheduler) или интрузивные задачи – рекомендуется

----

## Асинхронные задачи

В [fibers/mutex](/tasks/fibers/mutex) мы реализовали кооперативную многозадачность в виде _файберов_, которые были построены на _stackful_ корутинах.

В этом задании с помощью [_stackless_ корутин](https://en.cppreference.com/w/cpp/language/coroutines) мы реализуем кооперативную многозадачность в виде асинхронных "корутинных" _задач_ (_tasks_).

### Императивность

В этом задании асинхронные задачи будут императивно синхронизироваться друг с другом с помощью привычных примитивов – `Mutex` и `WaitGroup`. 

Мы назовем (конечно, не всерьез!) такие задачи _гор-рутинами_ (_gor-routines_) в честь одного из дизайнеров корутин в С++ – [Гора Нишанова](https://www.youtube.com/watch?v=_fu0gx-xseY).

### Декларативность

Наравне с поддержкой императивного стиля, фреймворк задач позволяет трансформировать и комбинировать асинхронные задачи в функциональном стиле с помощью `Task<T>`, этому будет посвящена отдельная задача.

## Gor-routines in Action

```cpp
void GorRoutinesExample() {
  using namespace exe;
  
  // Планировать корутины будет пул потоков
  // Никакой специальной подстройки под корутины от него не требуется
  executors::ThreadPool scheduler{4};

  // Лямбда-корутина - это функтор, у которого operator() является корутиной
  
  auto main = [&]() -> gorr::Task<> {
    co_await gorr::TeleportTo(scheduler);

    // Корутинам требуются собственные примитивы синхронизации
    gorr::Mutex mutex;
    size_t cs = 0;

    // Для простоты будем считать, что WaitGroup – одноразовый, 
    // т.е. его счетчик опускается до нуля только один раз
    gorr::WaitGroup wg;

    auto contender = [&]() -> gorr::Task<> {
      co_await gorr::TeleportTo(scheduler);
      // <-- Теперь корутина бежит в виде отдельной задачи в пуле потоков
      
      wheels::Defer defer([&wg]() {
        wg.Done();
      });

      for (size_t j = 0; j < 123456; ++j) {
        // Захватываем асинхронный мьютекс
        // Возможно, останавливаем текущую корутину на время ожидания,
        // но не блокируем при этом поток пула!
        // Здесь lock – это стандартный std::unique_lock
        auto lock = co_await mutex.ScopedLock();
        ++cs;  // В критической секции
      }  // <-- Синхронно отпускаем лок, деструкторы не могут быть асинхронными
    };

    wg.Add(17);
    for (size_t i = 0; i < 17; ++i) {
      // Стартуем корутину
      gorr::FireAndForget(contender());
    }
    
    co_await wg.Wait();
  };

  // Стартуем корутину
  gorr::FireAndForget(main());

  scheduler.WaitIdle();
  scheduler.Stop();
}
```

## Среда исполнения

Для исполнения корутин мы будем использовать уже написанный ранее фреймворк экзекуторов.

### Интрузивность

От экзекуторов нам требуется поддержка [интрузивных задач](exe/executors/task.hpp).

Интрузивность позволяет интегрировать корутины и экзекуторы без дополнительных аллокаций памяти:

Пусть корутина перепланируется в экзекутор:
```cpp
// Останавливаем корутину и возобновляем в задаче пула потоков
co_await gorr::TeleportTo(thread_pool);
```

Компилятор перепишет корутину в класс-автомат, который аллоцирует на куче при вызове корутины, а awaiter для `TeleportTo` поместит в поля этого класса.

Если теперь awaiter сделать узлом интрузивного списка и положить его в интрузивную очередь планировщика (например, пула потоков), то мы тем самым неявно свяжем остановленные корутины в список.

[Диаграмма](https://disk.yandex.ru/i/GkbluOq8Fn1BQA)

Узлы этого списка живут на стековых фреймах (вернее, coroutine state) корутин, но эти фреймы не разрушатся до тех пор, пока планировщик не достанет их awaiter-ы из очереди и не запустит корутины.

### `ManualExecutor`

Stackless корутины и stackful файберы исполняются не в конкретном пуле потоков, а в абстрактном планировщике – _экзекуторе_.

В этой задаче мы воспользуемся возможностью подменять для них планировщик: [юнит-тесты для корутин](tests/tasks/core/unit/main.cpp) написаны через `ManualExecutor` и исполняются детерминированно.

## Примитивы синхронизации

Как и файберы, корутины могут синхронизироваться через известные примитивы синхронизации. В этой задаче мы реализуем для корутин [`Mutex`](exe/gorr/sync/mutex.hpp) и [`WaitGroup`](exe/gorr/sync/wait_group.hpp).

### Реализация

В реализации примитивов синхронизации не должно быть динамических аллокаций памяти. Очереди ожидания делайте интрузивными, узлами в них будут awaiter-ы.

В реализации асинхронных методов в примитивах синхронизации нельзя будет написать цикл `while` с засыпанием внутри, `co_await` предусматривает только одну остановку корутины (точнее, не более одной).

Вам потребуется вариант `await_suspend`, который возвращает `bool`, а не `void`:
- `true` – awaiter запланировал возобновление корутины, сейчас корутина должна остановиться
- `false` означает, что корутина передумала останавливаться, она сразу выполнит `await_resume` и продолжит исполнение

В отличие от файберов, корутины не привязаны к планировщику, что создаст трудности при их возобновлении. 

#### `Mutex`

В методе `await_ready` awaiter-а мьютекса пробуйте захватить мьютекс без ожидания, с помощью `TryLock`.

Напишите лок-фри реализацию `Mutex`.

Вспомните реализацию мьютекса на трех состояниях:
- `0` – мьютекс свободен
- `1` – захвачен, но нет ждущих потоков
- `2` – захвачен, в очереди ожидания есть потоки

Затем материализуйте состояние `2` в явный интрузивный список awaiter-ов ждущих корутин.

#### `WaitGroup`

Выделите случай конкуренции `Wait` и последнего `Done` в отдельный класс `OneShotEvent`.

Сначала придумайте wait-free реализацию в предположении, что `Wait` вызывается только один раз: реализуйте _рандеву_ `Wait` и последнего `Done` / `Fire` (подобный сценарий возникает в реализации `Future`).

Затем поддержите нескольких waiter-ов: реализация естественно обобщится до лок-фри интрузивного списка ждущих корутин, идея будет похожа на лок-фри мьютекс.

Выполняйте оптимистичную проверку состояния `OneShotEvent` в `await_ready`.

Бонусный уровень: напишите многоразовый лок-фри `WaitGroup`.  

#### Быстрый планировщик

Если подставить в реализацию быстрый планировщик с локальными лок-фри очередями, то в исполнении корутин почти не будет взаимного исключения!

### `Task`

Корутина стартует лениво – при вызове она останавливается в точке `co_wait promise_object.initial_suspend()`, непосредственно перед выполнением процедуры пользователя.

Созданная, но еще не стартовавшая корутина (асинхронная задача) представляется экземпляром класса [`Task<T>`](exe/gorr/core/task.hpp).

```cpp
// Некая асинхронная корутина
// Параметр шаблона по умолчанию - Unit
gorr::Task<> Work(executors::ThreadPool& pool) {
  co_await gorr::TeleportTo(pool);
  // Тут выполняется полезная работа
}

// Работа пока не запланирована в пул потоков
gorr::Task<> task = Work();
```

Запустить корутину можно разными способами:

1) Вызов `gorr::FireAndForget(std::move(task))` запускает корутину `task` и инвалидирует `task`.
2) Вызов `gorr::Run(std::move(task))` запускает корутину `task` и блокирует текущий _поток_ до ее завершения, возвращает распакованный результат.
3) `co_await std::move(task)` запускает корутину `task` и останавливает текущую _корутину_ до завершения запущенной, возвращает распакованный результат.  

#### Реализация 

В задаче на месте `Task<T>` находится заглушка, которая поддерживает лишь `FireAndForget`. Для прохождения тестов ее будет достаточно, тесты используют только `FireAndForget` для запуска.

В качестве бонусного уровня можно реализовать полноценный `Task<T>`, который поддерживает `co_await`, `Run` и комбинаторы. 

## Задание

0) Поддержите интрузивные задачи в [futures/executors](/tasks/futures/executors).
1) Перенесите экзекуторы из [futures/executors](/tasks/futures/executors), корутины не потребуют от них изменений.
2) Реализуйте [`TeleportTo`](exe/gorr/run/teleport.hpp) и [`Yield`](exe/gorr/run/yield.hpp)
3) Реализуйте [`Mutex`](exe/gorr/sync/mutex.hpp)
4) Реализуйте лок-фри `Mutex`
5) Реализуйте одноразовый [`WaitGroup`](exe/gorr/sync/wait_group.hpp)
6) [Бонусный уровень] Реализуйте многоразовый `WaitGroup`
7) [Бонусный уровень] Реализуйте  [`Task<T>`](/exe/gorr/core/task.hpp), который поддерживает `co_await`, `Run` и комбинаторы.

## References

## Механика

- [Asymmetric Transfer](https://lewissbaker.github.io/)
- [cppreference / Coroutines](https://en.cppreference.com/w/cpp/language/coroutines)
- [dcl.fct.def.coroutine](https://eel.is/c++draft/dcl.fct.def.coroutine), [expr.await](https://eel.is/c++draft/expr.await#:co_await)

### Libraries

- [Folly](https://github.com/facebook/folly/tree/main/folly/experimental/coro)

### Talks

- [Gor Nishanov – C++ Coroutines – a negative overhead abstraction](https://www.youtube.com/watch?v=Ts-1mWBmTNE)
- [Roman Elizarov – Introduction to Coroutines](https://www.youtube.com/watch?v=_hfBv0a09Jc)
