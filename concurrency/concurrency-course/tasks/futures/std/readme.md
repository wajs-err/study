# (std) Future

В этой задаче мы напишем [`std::future`](https://en.cppreference.com/w/cpp/thread/future).

⚠️ Эта задача – только первый шаг к хорошим функциональным фьючам. Сама `std::future` к ним не относится.

## Sync / Async

Назовем операцию

- _Синхронной_ (_synchronous_), если возврат управления из вызова, который стартует эту операцию, означает завершение самой операции.
- _Асинхронной_ (_asynchronous_), если вызов, который стартует эту операцию, возвращает управление раньше, чем операция завершается.

Захват мьютекса (вызов `Lock`) – синхронная операция, планирование задачи в пул потоков (вызов `Submit`) – асинхронная.

Как должен выглядеть возврат результата для асинхронной операции? Каков ее return type?

## Future + Promise

Пара `Future<T>` + `Promise<T>` образует одноразовый _канал_ для возврата результата из асинхронной операции.

_Результат_ – значение типа `T` или исключение.

С каналом работают два потока:
- _Producer_ – поток, выполняющий асинхронную операцию
- _Consumer_ – поток, запускающий асинхронную операцию и потребляющий ее результат

Producer и consumer – это _роли_ потоков, один поток может совмещать разные роли.

Канал – одноразовый, передать можно только один результат.

`Promise<T>` – конец канала для записи, предоставляет producer-у два метода:
- `SetValue` для передачи значения и
- `SetException` для передачи исключения.

`Future<T>` – конец канала для чтения, предоставляет consumer-у единственный метод `Get`, который блокирует поток до тех пор, пока через `Promise` не будет отправлен результат.  

Пара `Future` + `Promise` образует _контракт_: producer обязуется выполнить контракт, отправив consumer-у либо значение, либо возникшую при вычислении значения ошибку.

### Пример

```cpp
// Пул потоков для вычислений
tp::ThreadPool pool{/*threads=*/4};

// Создаем "канал" или "контракт"
stdlike::Promise<int> p;
auto f = p.MakeFuture();

pool.Submit([p = std::move(p)]() mutable {
  std::this_thread::sleep_for(3s);  // <-- Тут можно представить тяжелое вычисление
  p.SetValue(42);  // <-- "Возвращаем" значение, исполняем контракт
});

int value = f.Get();  // <-- Дожидаемся значения
```

### Lifetimes 

Асинхронность приводит к несогласованности лайфтаймов:

- Consumer может не дожидаться значения на `Future`, вообще не вызывать метод `Get`. Так что `Future` может быть разрушена до того, как producer отправит результат через `Promise`.

- Producer может отправить результат и разрушить `Promise` до того, как consumer вызовет `Get` на `Future`.

## Указания по реализации

Используйте [`std::variant`](https://en.cppreference.com/w/cpp/utility/variant) для представления результата (значения / исключения)

Используйте [`std::exception_ptr`](https://en.cppreference.com/w/cpp/error/exception_ptr) для того, чтобы переносить исключения между потоками.

В этой задаче вы можете создавать новые файлы в директории `stdlike`.

Дополнительные классы, которые пользователь не должен использовать напрямую, спрячьте во вложенное пространство имен `stdlike::detail`.

### `void` vs `unit`

Для `T` = `void` потребуется специализация шаблона:
- метод `void SetValue(T)` у `Promise` нужно заменить на `void Set()`, 
- а `T Get()` у `Future` – на `void Wait()`. 

Мы не будем вслед за `std::future` поддерживать такую нерегулярность API и вместо `void` будем использовать `T` = [`std::monostate`](https://en.cppreference.com/w/cpp/utility/variant/monostate) (_unit_-тип, тип с единственным значением). 