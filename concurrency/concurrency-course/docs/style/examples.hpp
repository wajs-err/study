#pragma once

// "Пишите код так, как будто сопровождать его будет склонный к насилию психопат, который знает, где вы живёте"

// "Код в первую очередь пишется для людей, а не для машин"

// В основе - google style guide:
// https://google.github.io/styleguide/cppguide.html

// Главный принцип любого стайл гайда – постоянство:
// одинаковые отступы, одинаковый стиль именования переменных, оформления классов и т.п.

// Импорты упорядочивайте лексикографически
#include <atomic>
#include <condition_variable>
#include <mutex>
#include <thread>
// Отделяйте импорты от объявлений пустой строкой

// Именуйте классы в CamelCase
class TicketLock {
 // В первую очередь объявляйте публичные методы, именно они образуют интерфейс вашего класса

 // Читателю в первую очередь важно знать, что класс умеет, как им пользоваться,
 // в последнюю - какие у этого класса поля, ведь он не имеет к ним доступа.

 // Отступ для private/protected/public - 1 пробел.
 public:
  // Отступ - 2 пробела
  // Методы именуются в CamelCase
  void Lock() {
    // Для локальных переменных используйте snake_case
    // Используйте const всегда, когда это возможно, в аргументах функций и при объявлении локальных переменных
    const std::size_t this_thread_ticket = next_free_ticket_.fetch_add(1);

    // Разделяйте логические этапы в алгоритме пустыми строками
    // В данном случае мы разделяем doorway- и wait-секцию спинлока:
    while (this_thread_ticket != owner_ticket_.load()) { // После while и if ставьте пробел, ставьте пробел перед {
      std::this_thread::yield();
    }
  }

  // Разделяйте методы пустыми строками, это облегчает навигацию по коду
  // И снова CamelCase для методов:
  void Unlock() { // Открывающая скобка располагается на строке с именем функции, перед ней пробел
    // Между операторами и операндами ставьте пробелы: a + b
    owner_ticket_.store(owner_ticket_.load() + 1);
  }

 // Разделяйте пустыми строками секции в объявлении класса
 // Поля класса объявляйте в отдельной private секции
 // Обращаться к полям напрямую нельзя, менять состояние класса можно только через публичные методы
 private:
  // Для полей используйте snake_case
  // Имена полей должны завершаться нижним подчеркиванием, так их можно отделить от локальных переменных при чтении
  // Выбирайте для полей осмысленные имена, не сокращая слова
  std::atomic<std::size_t> next_free_ticket_{0}; // Инициализируем поля
  // Для счетчиков используйте тип size_t
  std::atomic<std::size_t> owner_ticket_{0};
};

// Классы разделяйте пустыми строками
class OnePassBarrier {
 public:
  // Сначала - конструкторы и публичные методы
  explicit OnePassBarrier(const std::size_t num_threads) // Аргументы - тоже const, если их не предполагается изменять
      : num_threads_{num_threads}, // Для списка инициализации отступ - 4 пробела
        num_threads_arrived_{0} {  // Поля выровнены
    // Внутри стандартный отступ (2 пробела)
  }

  // Если семантика класса не предполагает копирования или перемещения, то явно запретите эти операции
  OnePassBarrier(const OnePassBarrier&) = delete;
  OnePassBarrier(OnePassBarrier&&) = delete;
  // ...

  // Методы разделяйте пустыми строками
  void Pass() {
    // Не захватывайте мьютексы руками, всегда используйте RAII
    // Для std::unique_lock используйте имя locker, для std::lock_guard-а - guard
    // Используйте std::lock_guard, когда мьютекс не планируется отпускать до выхода из скоупа,
    // std::unique_lock - в связке с ожиданием на условной переменной
    std::unique_lock lock(mutex_);

    ++num_threads_arrived_;
    if (num_threads_arrived_ == num_threads_) {
      // Даже один statement под if-ом оформляйте в блок, явные границы упрощают чтение кода
      // и позволяют избежать ошибок в будущем при рефакторинге
      all_threads_arrived_cv_.notify_all(); 
    } else {
      while (num_threads_arrived_ < num_threads_) {
        all_threads_arrived_cv_.wait(lock);
      }
      // Эквивалентная запись такого цикла ожидания: cv.wait(lock, predicate)
    }
  }

 // Секции (public / private) отбивайте пустыми строками
 private:
  // Для числа объектов используйте имена num_apples или apple_count
  // Всегда указывайте, какие именно объекты вы считаете
  std::size_t num_threads_;
  std::mutex mutex_;
  // Имя условной переменной должно отражать предикат (условие), которого на ней дожидаются
  std::condition_variable all_threads_arrived_cv_;
  // Если поток читает/пишет в переменную только под мьютексом, то ее не нужно делать атомиком
  std::size_t num_threads_arrived_;
};
